<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Eric Bridgeford" />

<meta name="date" content="2017-08-02" />

<title>Bernoulli Coherent Subgraph Estimation</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Bernoulli Coherent Subgraph Estimation</h1>
<h4 class="author"><em>Eric Bridgeford</em></h4>
<h4 class="date"><em>2017-08-02</em></h4>



<p>In this tutorial, we discuss our estimator of a bernoulli distribution per edge for a given graph, and the strategies to identify a coherent subgraph from the data. Using our estimators, we develop a Bayes Plugin Classifier.</p>
<div id="framework" class="section level1">
<h1>Framework</h1>
<div id="setting" class="section level2">
<h2>Setting</h2>
<ul>
<li><span class="math inline">\(\mathbb{G}: \Omega \rightarrow \mathcal{G}\)</span> is a graph-valued RV with samples <span class="math inline">\(G_i \sim \mathbb{G}\)</span>.</li>
<li>For each <span class="math inline">\(G_i \in \mathcal{G}\)</span>, we have <span class="math inline">\(G_i = (V, E_i)\)</span>; that is, each <span class="math inline">\(G_i\)</span> is defined by a set of vertices <span class="math inline">\(V\)</span> and a set of edges <span class="math inline">\(E_i\)</span>, where <span class="math inline">\(w_i: V \times V \rightarrow \{0, 1\}\)</span>, and <span class="math inline">\(w_i(e_{uv}) \in \{0, 1\}\)</span>. That is, each graph has binary edges. Our graphs should also be undirected.</li>
<li>We have a collection of classes <span class="math inline">\(\mathcal{Y}\)</span> where the collection of graphs in class <span class="math inline">\(y_i\)</span> have a class-conditional difference with the collection of graphs in class <span class="math inline">\(y_j\)</span> for <span class="math inline">\(i \neq j\)</span>.</li>
<li><span class="math inline">\(\mathbb{A}_y: \Omega \rightarrow \mathcal{A}_y\)</span>, a adjacency-matrix-valued RV with samples <span class="math inline">\(A_{i | y_i = y} \sim \mathbb{A}_y\)</span>, where <span class="math inline">\(\mathcal{A}_y\)</span> is the space of possible adjacency-matrices and <span class="math inline">\(A_{i | y_i = y} \in \mathcal{A}_y\)</span>.</li>
<li><span class="math inline">\(A_{i | y_i = y} \in \mathcal{A}_y\)</span>, and <span class="math inline">\(\mathcal{A}_y \subseteq \mathbb{R}^{V \times V}\)</span>.</li>
<li>Each graph <span class="math inline">\(G_i\)</span> can be represented as an adjacency-matrix <span class="math inline">\(A_i\)</span>.</li>
<li>Within each graph, there exists some collection of vertices called the signal vertices that capture the class-conditional difference in the data. From the edges incident the signal vertices, the edges <span class="math inline">\(\mathcal{S}\)</span> called the subgraph contain the bulk of the class differences.</li>
</ul>
</div>
<div id="statistical-goal" class="section level2">
<h2>Statistical Goal</h2>
<p>Identify the sufficient parameters to characterize the distribution of connected and disconnected edges. Identify the edges that are most likely to show a class-conditional difference from the edges incident the signal vertices, the subgraph. Use the subgraph and the related estimators to produce a bayes-plugin classifier that allows us to accurately predict the class of items.</p>
</div>
<div id="model" class="section level2">
<h2>Model</h2>
<p>Assume that the edge weights can be characterized by a bernoulli RV; that is:</p>
<span class="math display">\[\begin{align}
  \mathbb{A}_{uv} \sim Bern(p_{uv})
\end{align}\]</span>
<p>where <span class="math inline">\(p_{uv|y}\)</span> is the probability of edge <span class="math inline">\(e_{uv}\)</span> being connected in class <span class="math inline">\(y\)</span>.</p>
<p>Then our likelihood function is simply:</p>
<span class="math display">\[\begin{align}
  L_{\mathbb{A}, Y}(A_i, y; \theta) &amp;= \prod_{(u, v) \in \mathcal{S}} Bern(w_i(e_{uv}); p_{uv | y}) \\
  &amp;= \prod_{(u, v) \in \mathcal{S}} p_{uv | y}^{w_i(e_{uv})}(1 - p_{uv | y})^{1 - w_i(e_{uv})}
\end{align}\]</span>
<p>where <span class="math inline">\(\mathcal{S}\)</span> is our subgraph.</p>
</div>
</div>
<div id="estimators" class="section level1">
<h1>Estimators</h1>
<div id="bernoulli-parameters" class="section level2">
<h2>Bernoulli Parameters</h2>
<p>Using MLE, it is easy to see that:</p>
<span class="math display">\[\begin{align}
  \hat{p}_{uv | y} = \frac{1}{n} \sum_{i | y_i = y} w_i(e_{uv})
\end{align}\]</span>
<p>where <span class="math inline">\(w_i(e_{uv}) \in \{0, 1\}\)</span> is the binary edge weight of edge <span class="math inline">\(e_{uv}\)</span>.</p>
<p>Note that if <span class="math inline">\(w_i(e_{uv}) = 0 \;\forall i\)</span>, then <span class="math inline">\(p_{uv} = 0\)</span>, which is undesirable since we only have a finite sample (and successive samples where <span class="math inline">\(w_i(e_{uv})) \neq 0\)</span> would lead to poor model performance), and vice versa for <span class="math inline">\(p_{uv} = 1\)</span> when <span class="math inline">\(w_i(e_{uv}) = 0 \;\forall i\)</span>. Then consider the smoothed estimator:</p>
<span class="math display">\[\begin{align}
  \hat{p}_{uv | y} = \begin{cases}
    n_n &amp; max_{i | y_i = y}(w_i(e_{uv})) = 0 \\
    1-n_n &amp; max_{i | y_i = y}(w_i(e_{uv})) = 1 \\
    \hat{p}_{uv | y} &amp; else
  \end{cases}
\end{align}\]</span>
</div>
<div id="priors" class="section level2">
<h2>Priors</h2>
<p>Here, we take the maximum likelihood estimators for the prior probabilities, which assuming our data is sampled iid from our population, should suffice:</p>
<span class="math display">\[\begin{align}
  \hat{\pi}_y = \frac{n_y}{n}
\end{align}\]</span>
<p>where <span class="math inline">\(n_y = \sum_{i =1}^n \mathbb{I}\{y_i = y\}\)</span>.</p>
</div>
<div id="coherent-subgraph" class="section level2">
<h2>Coherent Subgraph</h2>
<p>To estimate the coherent subgraph, we consider the following algorithm:</p>
<p>coherent_subgraph(G, e, s): + assemble a contingency matrix, per edge, counting the number of occurences of a graph from each class having or not having a connection. + compute the p-value of Fisherâ€™s exact test on the contingency matrix for each edge to produce the test statistic <span class="math inline">\(T_{uv}\)</span>. The <span class="math inline">\(p\)</span> value signifies the probability of the null hypothesis, that there is no class-conditional difference present for edge <span class="math inline">\(uv\)</span>, versus the alternative that there is a class-conditional difference present for edge <span class="math inline">\(uv\)</span>. + for <span class="math inline">\(p\)</span> in sort(unique_p_vals, increasing): # all of the unique p-values in our contingency matrix ordered by significance + compute the signal of each vertex as the number of edges incident the given vertex with test-statistics less than the iteration of <span class="math inline">\(p\)</span> we are on. That is, $s_i = <em>{u } {T</em>{u v_i} p }. + order the vertices <span class="math inline">\(s_i^{(1)} \geq s_j^{(2)} \geq ...\)</span> and take the top <span class="math inline">\(s\)</span> as our signal vertices <span class="math inline">\(V^*\)</span>. + Check whether <span class="math inline">\(\sum_{i=1}^{\left|V^*\right|} \geq e\)</span>. If so, continue. If not, increment to the next value of <span class="math inline">\(p\)</span>. + order the test statistics in increasing order, such that <span class="math inline">\(T^{(1)}_{uv} \leq T^{(2)}_{u'v'} \leq ...\)</span> for all the edges where <span class="math inline">\(v_i, v_j, ...\)</span> are our signal vertices <span class="math inline">\(V^*\)</span>. + choose the first <span class="math inline">\(e\)</span> edges as a coherent estimator of the signal-subgraph <span class="math inline">\(\hat{\mathcal{S}}\)</span>.</p>
</div>
<div id="classification" class="section level2">
<h2>Classification</h2>
<p>We can use our Bernoulli probabilities to explicitly define a Bayes-Plugin classifier:</p>
<span class="math display">\[\begin{align}
  h_*(G; \mathcal{T}) = \textrm{argmax}_{y \in Y} \prod_{(u, v) \in \hat{\mathcal{S}}} \hat{p}_{uv | y}^{a_{uv}}(1 - \hat{p}_{uv | y})^{1 - a_{uv}}\hat{\pi}_y
\end{align}\]</span>
<p>where <span class="math inline">\(a_{uv}\)</span> is the <span class="math inline">\((u, v)\)</span> edge of graph <span class="math inline">\(G\)</span>, and <span class="math inline">\(h_*(\cdot; \mathcal{T})\)</span> is the hypothesis of the model constructed given training set <span class="math inline">\(\mathcal{T}\)</span>.</p>
</div>
</div>
<div id="evaluation" class="section level1">
<h1>Evaluation</h1>
<div id="cross-validated-error" class="section level2">
<h2>Cross-validated Error</h2>
<p>We will evaluate our model performance with the cross-validated error:</p>
<span class="math display">\[\begin{align}
  \hat{L}_{\hat{h}(\cdot, \mathcal{T}_n)} &amp;= \frac{1}{C} \sum_{i=1}^C \frac{1}{\left| \mathcal{T}_n \setminus \mathcal{T}_C \right|} \sum_{G \notin \mathcal{T}_C} \mathbb{I}\left\{\hat{h} \left(G; \mathcal{T}_C \right)\right\}
\end{align}\]</span>
<p>where <span class="math inline">\(\mathcal{T}_C\)</span> is the set of graphs that we trained our model on.</p>
<p>Additionally, we can estimate a <span class="math inline">\(p\)</span> value using Monte Carlo permutations. We perform this by randomly permuting our labels <span class="math inline">\(n\)</span> times, and then using the permuted labels to construct our estimators and our bayes-plugin classifier. We then feed in our testing data and similarly compute a loss for each of our <span class="math inline">\(n\)</span> permutations. We report our <span class="math inline">\(p\)</span> value as the fraction of Monte Carlo permutations that perform better than our classifier given the correctly labelled data.</p>
</div>
<div id="misclassification-rate" class="section level2">
<h2>Misclassification Rate</h2>
<p>During our simulations, since we are constructing simulated data, we will know ahead of time whether an edge is or is not part of the subgraph. To quantify this performance, we consider the edge-misclassification rate:</p>
<span class="math display">\[\begin{align}
  R_n^x = \frac{1}{\left|\mathcal{S}\right|} \sum_{(u, v) \in \mathcal{S}}\mathbb{I}\left\{(u, v) \notin \hat{\mathcal{S}}\right\
\end{align}\]</span>
<p>or the fraction of edges that are part of the true subgraph <span class="math inline">\(\mathcal{S}\)</span> but not the estimated subgraph <span class="math inline">\(\mathcal{\hat{S}}\)</span>.</p>
</div>
</div>
<div id="simulations" class="section level1">
<h1>Simulations</h1>
<div id="easy-example" class="section level2">
<h2>Easy Example</h2>
<p>In this example, we will explore the situation that an incoherent subgraph classifier was not able to appropriately handle. Consider the case where we have a far more subtle class-conditional variation, and the bulk of the class-conditional variation captured by only the edges incident a smaller number of our vertices known as the signal vertices. This situation, known as a coherent subgraph, allows us to focus on the vertices that matter most, and consider from this subset the edges that matter most. In this example, we will consider 9 vertex graphs, with 10 signal edges distributed about signal vertices 1 and 3:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(subgraphing)
<span class="kw">require</span>(ggplot2)
<span class="kw">require</span>(reshape2)
<span class="kw">require</span>(fmriutils)
<span class="kw">require</span>(Rmisc)

lseq &lt;-<span class="st"> </span>function(from, to, n) {
  <span class="kw">return</span>(<span class="kw">round</span>(<span class="kw">exp</span>(<span class="kw">seq</span>(<span class="kw">log</span>(from), <span class="kw">log</span>(to), <span class="dt">length.out =</span> n))))
}

xdim &lt;-<span class="st"> </span><span class="dv">9</span>
ydim &lt;-<span class="st"> </span><span class="dv">9</span>
c &lt;-<span class="st"> </span><span class="dv">2</span>  <span class="co"># number of classes</span>
p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, c))

signal_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">23</span>, <span class="dv">26</span>, <span class="dv">21</span>)
p1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(xdim*ydim), <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim))
p1[<span class="kw">upper.tri</span>(p1, <span class="dt">diag=</span><span class="ot">FALSE</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>

p2 &lt;-<span class="st"> </span>p1
for (e in <span class="kw">c</span>(signal_edges)) {
  p1[e] &lt;-<span class="st"> </span>.<span class="dv">3</span>
  p2[e] &lt;-<span class="st"> </span>.<span class="dv">7</span>
}

p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">t</span>(p1) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p1))
p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">t</span>(p2) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p2))
p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2

ns =<span class="st"> </span><span class="dv">100</span>

samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim, ns*<span class="dv">2</span>))
samp[,,<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>ns)
samp[,,(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>ns)

Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(ns*<span class="dv">2</span>))
Y[<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="dv">0</span>
Y[(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="dv">1</span>


plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
sg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim))
sg[signal_edges] &lt;-<span class="st"> </span><span class="dv">1</span>
sg &lt;-<span class="st"> </span>sg +<span class="st"> </span><span class="kw">t</span>(sg) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(sg))
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(sg, <span class="dt">title=</span><span class="st">&quot;True Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># approximate estimators and contingency table</span>
train &lt;-<span class="st"> </span><span class="kw">sg.bern.subgraph_train</span>(samp, Y, <span class="dv">12</span>, <span class="dt">coherent=</span><span class="dv">2</span>, <span class="dt">tstat =</span> <span class="st">&quot;fisher&quot;</span>)

<span class="co"># visualize the two probability matrices</span>
plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
estsg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim))
estsg[train$edges] &lt;-<span class="st"> </span><span class="dv">1</span>
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(estsg, <span class="dt">title=</span><span class="st">&quot;Estimated Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>As we can see, we correctly identify the signal vertices, as evinced by the fact that all of the signal edges found are incident to vertices 1 or 3. We get perfect estimation of the subgraph.</p>
</div>
<div id="harder-example" class="section level2">
<h2>Harder Example</h2>
<p>Starting from our previous simulation, we will now add 0-mean gaussian noise with <span class="math inline">\(\sigma=.05\)</span> to our probability matrices to simulate minor class variation in all of the edges. Additionally, with probability <span class="math inline">\(p=.25\)</span> we will rewire (that is, change the connection from connected to unconnected, or vice versa) each edge for each graph. This means that there will be other edges at random that also may look like signal vertices, but these edges (since they are rewired at random) will be purely noise. Theoretically, since the edges that have signal are concentrated in only 2 vertices, running the signal subgraph classifier and indicating a coherency of 2 should give us a good approximation of our signal subgraph:</p>
<p>We first visualize a single example with <span class="math inline">\(n=100\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(subgraphing)
<span class="kw">require</span>(ggplot2)
<span class="kw">require</span>(reshape2)
<span class="kw">require</span>(fmriutils)
<span class="kw">require</span>(Rmisc)

lseq &lt;-<span class="st"> </span>function(from, to, n) {
  <span class="kw">return</span>(<span class="kw">round</span>(<span class="kw">exp</span>(<span class="kw">seq</span>(<span class="kw">log</span>(from), <span class="kw">log</span>(to), <span class="dt">length.out =</span> n))))
}

xdim &lt;-<span class="st"> </span><span class="dv">9</span>
ydim &lt;-<span class="st"> </span><span class="dv">9</span>
c &lt;-<span class="st"> </span><span class="dv">2</span>  <span class="co"># number of classes</span>
p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, c))

signal_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">23</span>, <span class="dv">26</span>, <span class="dv">21</span>)
p1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(xdim*ydim), <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim))
p1[<span class="kw">upper.tri</span>(p1, <span class="dt">diag=</span><span class="ot">FALSE</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>

p2 &lt;-<span class="st"> </span>p1
for (e in <span class="kw">c</span>(signal_edges)) {
  p1[e] &lt;-<span class="st"> </span>.<span class="dv">3</span>
  p2[e] &lt;-<span class="st"> </span>.<span class="dv">7</span>
}

p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">t</span>(p1) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p1)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">t</span>(p2) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p2)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2

ns =<span class="st"> </span><span class="dv">100</span>

samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim, ns*<span class="dv">2</span>))
samp[,,<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>ns, <span class="dt">rewire=</span>.<span class="dv">25</span>)
samp[,,(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>ns, <span class="dt">rewire=</span>.<span class="dv">25</span>)

Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(ns*<span class="dv">2</span>))
Y[<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="dv">0</span>
Y[(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="dv">1</span>


plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
sg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim))
sg[signal_edges] &lt;-<span class="st"> </span><span class="dv">1</span>
sg &lt;-<span class="st"> </span>sg +<span class="st"> </span><span class="kw">t</span>(sg) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(sg))
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(sg, <span class="dt">title=</span><span class="st">&quot;True Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># approximate estimators and contingency table</span>
train &lt;-<span class="st"> </span><span class="kw">sg.bern.subgraph_train</span>(samp, Y, <span class="dv">12</span>, <span class="dt">coherent=</span><span class="dv">2</span>, <span class="dt">tstat =</span> <span class="st">&quot;fisher&quot;</span>)

<span class="co"># visualize the two probability matrices</span>
plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
estsg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim))
estsg[train$edges] &lt;-<span class="st"> </span><span class="dv">1</span>
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(estsg, <span class="dt">title=</span><span class="st">&quot;Estimated Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Despite not getting a perfect subgraph, we still end up getting 75% (9/12) of the edges right, and correctly estimated that vertices 1 and 3 were our signal vertices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ns &lt;-<span class="st"> </span><span class="kw">lseq</span>(<span class="dv">10</span>, <span class="dv">300</span>, <span class="dv">8</span>)
nes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">6</span>, <span class="dv">10</span>, <span class="dv">14</span>)
results &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">n=</span><span class="kw">c</span>(), <span class="dt">nedges=</span><span class="kw">c</span>(), <span class="dt">error=</span><span class="kw">c</span>(), <span class="dt">miss_edge=</span><span class="kw">c</span>())
for (sim in <span class="dv">1</span>:<span class="dv">10</span>) {
  <span class="kw">print</span>(sim)
  xdim &lt;-<span class="st"> </span><span class="dv">9</span>
  ydim &lt;-<span class="st"> </span><span class="dv">9</span>
  c &lt;-<span class="st"> </span><span class="dv">2</span>  <span class="co"># number of classes</span>
  p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, c))
  
  signal_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">23</span>, <span class="dv">26</span>, <span class="dv">21</span>)
  p1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(xdim*ydim), <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim))
  p1[<span class="kw">upper.tri</span>(p1, <span class="dt">diag=</span><span class="ot">FALSE</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>
  
  p2 &lt;-<span class="st"> </span>p1
  for (e in <span class="kw">c</span>(signal_edges)) {
    p1[e] &lt;-<span class="st"> </span>.<span class="dv">3</span>
    p2[e] &lt;-<span class="st"> </span>.<span class="dv">7</span>
  }
  
  p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">t</span>(p1) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p1)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
  p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">t</span>(p2) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p2)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
  p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
  p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
  p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2
  
  for (n in ns) {
    samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, n*<span class="dv">2</span>))
    samp[,,<span class="dv">1</span>:n] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>n, <span class="dt">rewire=</span>.<span class="dv">25</span>)
    samp[,,(n<span class="dv">+1</span>):(<span class="dv">2</span>*n)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>n, <span class="dt">rewire=</span>.<span class="dv">25</span>)
    
    Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(n*<span class="dv">2</span>))
    Y[<span class="dv">1</span>:n] &lt;-<span class="st"> </span><span class="dv">0</span>
    Y[(n<span class="dv">+1</span>):(<span class="dv">2</span>*n)] &lt;-<span class="st"> </span><span class="dv">1</span>
    for (ne in nes) {
      class_res &lt;-<span class="st"> </span><span class="kw">sg.bern.xval_classifier</span>(<span class="dt">samp=</span>samp, <span class="dt">Y=</span>Y, <span class="dt">nedge=</span>ne, <span class="dt">tstat=</span><span class="st">&quot;fisher&quot;</span>, <span class="dt">coherent =</span> <span class="dv">2</span>, <span class="dt">xval=</span><span class="st">&quot;loo&quot;</span>)
      true_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">28</span>, <span class="dv">55</span>, <span class="dv">73</span>, <span class="dv">19</span>, <span class="dv">37</span>, <span class="dv">64</span>)
      miss_edge &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span><span class="dv">1</span>/<span class="kw">length</span>(true_edges)*<span class="kw">sum</span>(true_edges %in%<span class="st"> </span>class_res$edges)
      results &lt;-<span class="st"> </span><span class="kw">rbind</span>(results, <span class="kw">data.frame</span>(<span class="dt">n=</span>n, <span class="dt">nedges=</span>ne, <span class="dt">error=</span>class_res$error, <span class="dt">miss_edge=</span>miss_edge))    
    }
  }
}</code></pre></div>
<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">results$nedges &lt;-<span class="st"> </span><span class="kw">factor</span>(results$nedges)
me_plot &lt;-<span class="st"> </span><span class="kw">ggplot</span>(results, <span class="kw">aes</span>(<span class="dt">x=</span>n, <span class="dt">y=</span>miss_edge, <span class="dt">color=</span>nedges, <span class="dt">group=</span>nedges)) +
<span class="st">  </span><span class="kw">geom_point</span>() +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.y =</span> mean, <span class="dt">geom =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.data =</span> mean_se, <span class="dt">geom =</span> <span class="st">&quot;errorbar&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Proportion of Edges Missed by Coherent Subgraph Estimator&quot;</span>) +
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Number of Training Examples per Class&quot;</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Missed-Edge Rate&quot;</span>)

xv_plot &lt;-<span class="st"> </span><span class="kw">ggplot</span>(results, <span class="kw">aes</span>(<span class="dt">x=</span>n, <span class="dt">y=</span>error, <span class="dt">color=</span>nedges, <span class="dt">group=</span>nedges)) +
<span class="st">  </span><span class="kw">geom_point</span>() +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.y =</span> mean, <span class="dt">geom =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.data =</span> mean_se, <span class="dt">geom =</span> <span class="st">&quot;errorbar&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Error of Model Estimated with Leave-One-Out Cross Validation&quot;</span>) +
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Number of Training Examples per Class&quot;</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Cross-Validated Error&quot;</span>)

<span class="kw">multiplot</span>(me_plot, xv_plot, <span class="dt">cols=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
