<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Eric Bridgeford" />

<meta name="date" content="2017-08-02" />

<title>Bernoulli Incoherent Subgraph Estimation</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Bernoulli Incoherent Subgraph Estimation</h1>
<h4 class="author"><em>Eric Bridgeford</em></h4>
<h4 class="date"><em>2017-08-02</em></h4>



<p>In this tutorial, we discuss our estimator of a bernoulli distribution per edge for a given graph, and the strategies to identify an incoherent subgraph from the data. Using our estimators, we develop a Bayes Plugin Classifier.</p>
<div id="framework" class="section level1">
<h1>Framework</h1>
<div id="setting" class="section level2">
<h2>Setting</h2>
<ul>
<li><span class="math inline">\(\mathbb{G}: \Omega \rightarrow \mathcal{G}\)</span> is a graph-valued RV with samples <span class="math inline">\(G_i \sim \mathbb{G}\)</span>.</li>
<li>For each <span class="math inline">\(G_i \in \mathcal{G}\)</span>, we have <span class="math inline">\(G_i = (V, E_i)\)</span>; that is, each <span class="math inline">\(G_i\)</span> is defined by a set of vertices <span class="math inline">\(V\)</span> and a set of edges <span class="math inline">\(E_i\)</span>, where <span class="math inline">\(w_i: V \times V \rightarrow \{0, 1\}\)</span>, and <span class="math inline">\(w_i(e_{uv}) \in \{0, 1\}\)</span>. That is, each graph has binary edges.</li>
<li>We have a collection of classes <span class="math inline">\(\mathcal{Y}\)</span> where the collection of graphs in class <span class="math inline">\(y_i\)</span> have a class-conditional difference with the collection of graphs in class <span class="math inline">\(y_j\)</span> for <span class="math inline">\(i \neq j\)</span>.</li>
<li><span class="math inline">\(\mathbb{A}_y: \Omega \rightarrow \mathcal{A}_y\)</span>, a adjacency-matrix-valued RV with samples <span class="math inline">\(A_{i | y_i = y} \sim \mathbb{A}_y\)</span>, where <span class="math inline">\(\mathcal{A}_y\)</span> is the space of possible adjacency-matrices and <span class="math inline">\(A_{i | y_i = y} \in \mathcal{A}_y\)</span>.</li>
<li><span class="math inline">\(A_{i | y_i = y} \in \mathcal{A}_y\)</span>, and <span class="math inline">\(\mathcal{A}_y \subseteq \mathbb{R}^{V \times V}\)</span>.</li>
<li>Each graph <span class="math inline">\(G_i\)</span> can be represented as an adjacency-matrix <span class="math inline">\(A_i\)</span>.</li>
<li>Within each graph, there exists some collection of edges <span class="math inline">\(\mathcal{S}\)</span> called the subgraph that contain the bulk of the class differences.</li>
</ul>
</div>
<div id="statistical-goal" class="section level2">
<h2>Statistical Goal</h2>
<p>Identify the sufficient parameters to characterize the distribution of connected and disconnected edges. Identify the edges that are most likely to show a class-conditional difference, the subgraph. Use the subgraph and the related estimators to produce a bayes-plugin classifier that allows us to accurately predict the class of items.</p>
</div>
<div id="model" class="section level2">
<h2>Model</h2>
<p>Assume that the edge weights can be characterized by a bernoulli RV; that is:</p>
<span class="math display">\[\begin{align}
  \mathbb{A}_{uv} \sim Bern(p_{uv})
\end{align}\]</span>
<p>where <span class="math inline">\(p_{uv|y}\)</span> is the probability of edge <span class="math inline">\(e_{uv}\)</span> being connected in class <span class="math inline">\(y\)</span>.</p>
<p>Then our likelihood function is simply:</p>
<span class="math display">\[\begin{align}
  L_{\mathbb{A}, Y}(A_i, y; \theta) &amp;= \prod_{(u, v) \in \mathcal{S}} Bern(w_i(e_{uv}); p_{uv | y}) \\
  &amp;= \prod_{(u, v) \in \mathcal{S}} p_{uv | y}^{w_i(e_{uv})}(1 - p_{uv | y})^{1 - w_i(e_{uv})}
\end{align}\]</span>
<p>where <span class="math inline">\(\mathcal{S}\)</span> is our subgraph.</p>
</div>
</div>
<div id="estimators" class="section level1">
<h1>Estimators</h1>
<div id="bernoulli-parameters" class="section level2">
<h2>Bernoulli Parameters</h2>
<p>Using MLE, it is easy to see that:</p>
<span class="math display">\[\begin{align}
  \hat{p}_{uv | y} = \frac{1}{n} \sum_{i | y_i = y} w_i(e_{uv})
\end{align}\]</span>
<p>where <span class="math inline">\(w_i(e_{uv}) \in \{0, 1\}\)</span> is the binary edge weight of edge <span class="math inline">\(e_{uv}\)</span>.</p>
<p>Note that if <span class="math inline">\(w_i(e_{uv}) = 0 \;\forall i\)</span>, then <span class="math inline">\(p_{uv} = 0\)</span>, which is undesirable since we only have a finite sample (and successive samples where <span class="math inline">\(w_i(e_{uv})) \neq 0\)</span> would lead to poor model performance), and vice versa for <span class="math inline">\(p_{uv} = 1\)</span> when <span class="math inline">\(w_i(e_{uv}) = 0 \;\forall i\)</span>. Then consider the smoothed estimator:</p>
<span class="math display">\[\begin{align}
  \hat{p}_{uv | y} = \begin{cases}
    n_n &amp; max_{i | y_i = y}(w_i(e_{uv})) = 0 \\
    1-n_n &amp; max_{i | y_i = y}(w_i(e_{uv})) = 1 \\
    \hat{p}_{uv | y} &amp; else
  \end{cases}
\end{align}\]</span>
</div>
<div id="priors" class="section level2">
<h2>Priors</h2>
<p>Here, we take the maximum likelihood estimators for the prior probabilities, which assuming our data is sampled iid from our population, should suffice:</p>
<span class="math display">\[\begin{align}
  \hat{\pi}_y = \frac{n_y}{n}
\end{align}\]</span>
<p>where <span class="math inline">\(n_y = \sum_{i =1}^n \mathbb{I}\{y_i = y\}\)</span>.</p>
</div>
<div id="incoherent-subgraph" class="section level2">
<h2>Incoherent Subgraph</h2>
<p>To estimate the incoherent subgraph, we consider the following algorithm:</p>
<p>incoherent_subgraph(G, e):</p>
<ul>
<li>assemble a contingency matrix, per edge, counting the number of occurences of a graph from each class having or not having a connection.</li>
<li>compute the p-value of Fisher’s exact test on the contingency matrix for each edge to produce the test statistic <span class="math inline">\(T_{uv}\)</span>. The <span class="math inline">\(p\)</span> value signifies the probability of the null hypothesis, that there is no class-conditional difference present for edge <span class="math inline">\(uv\)</span>, versus the alternative that there is a class-conditional difference present for edge <span class="math inline">\(uv\)</span>.</li>
<li>order the test statistics in increasing order, such that <span class="math inline">\(T^{(1)}_{uv} \leq T^{(2)}_{u'v'} \leq ...\)</span> for all the edges.</li>
<li>choose the first <span class="math inline">\(e\)</span> edges as estimator of the signal-subgraph <span class="math inline">\(\hat{\mathcal{S}}\)</span>.</li>
</ul>
</div>
<div id="classification" class="section level2">
<h2>Classification</h2>
<p>We can use our Bernoulli probabilities to explicitly define a Bayes-Plugin classifier:</p>
<span class="math display">\[\begin{align}
  h_*(G; \mathcal{T}) = \textrm{argmax}_{y \in Y} \prod_{(u, v) \in \hat{\mathcal{S}}} \hat{p}_{uv | y}^{a_{uv}}(1 - \hat{p}_{uv | y})^{1 - a_{uv}}\hat{\pi}_y
\end{align}\]</span>
<p>where <span class="math inline">\(a_{uv}\)</span> is the <span class="math inline">\((u, v)\)</span> edge of graph <span class="math inline">\(G\)</span>, and <span class="math inline">\(h_*(\cdot; \mathcal{T})\)</span> is the hypothesis of the model constructed given training set <span class="math inline">\(\mathcal{T}\)</span>.</p>
</div>
</div>
<div id="evaluation" class="section level1">
<h1>Evaluation</h1>
<div id="cross-validated-error" class="section level2">
<h2>Cross-validated Error</h2>
<p>We will evaluate our model performance with the cross-validated error:</p>
<span class="math display">\[\begin{align}
  \hat{L}_{\hat{h}(\cdot, \mathcal{T}_n)} &amp;= \frac{1}{C} \sum_{i=1}^C \frac{1}{\left| \mathcal{T}_n \setminus \mathcal{T}_C \right|} \sum_{G \notin \mathcal{T}_C} \mathbb{I}\left\{\hat{h} \left(G; \mathcal{T}_C \right)\right\}
\end{align}\]</span>
<p>where <span class="math inline">\(\mathcal{T}_C\)</span> is the set of graphs that we trained our model on.</p>
<p>Additionally, we can estimate a <span class="math inline">\(p\)</span> value using Monte Carlo permutations. We perform this by randomly permuting our labels <span class="math inline">\(n\)</span> times, and then using the permuted labels to construct our estimators and our bayes-plugin classifier. We then feed in our testing data and similarly compute a loss for each of our <span class="math inline">\(n\)</span> permutations. We report our <span class="math inline">\(p\)</span> value as the fraction of Monte Carlo permutations that perform better than our classifier given the correctly labelled data.</p>
</div>
<div id="misclassification-rate" class="section level2">
<h2>Misclassification Rate</h2>
<p>During our simulations, since we are constructing simulated data, we will know ahead of time whether an edge is or is not part of the subgraph. To quantify this performance, we consider the edge-misclassification rate:</p>
<span class="math display">\[\begin{align}
  R_n^x = \frac{1}{\left|\mathcal{S}\right|} \sum_{(u, v) \in \mathcal{S}}\mathbb{I}\left\{(u, v) \notin \hat{\mathcal{S}}\right\
\end{align}\]</span>
<p>or the fraction of edges that are part of the true subgraph <span class="math inline">\(\mathcal{S}\)</span> but not the estimated subgraph <span class="math inline">\(\mathcal{\hat{S}}\)</span>.</p>
</div>
</div>
<div id="simulations" class="section level1">
<h1>Simulations</h1>
<div id="easy-simulation" class="section level2">
<h2>Easy Simulation</h2>
<p>In our basic simulation, we will use 2 classes with 4x4 probability matrices. The probability matrix for each class will be identical, except for 4 randomly selected edges, in which the probability for class 1 will be .25, and the probability for class 2 will be .75.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(subgraphing)
<span class="kw">require</span>(ggplot2)
<span class="kw">require</span>(reshape2)
<span class="kw">require</span>(fmriutils)
<span class="kw">require</span>(Rmisc)

lseq &lt;-<span class="st"> </span>function(from, to, n) {
  <span class="kw">return</span>(<span class="kw">round</span>(<span class="kw">exp</span>(<span class="kw">seq</span>(<span class="kw">log</span>(from), <span class="kw">log</span>(to), <span class="dt">length.out =</span> n))))
}

n =<span class="st"> </span><span class="dv">4</span>

p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(n^<span class="dv">2</span>), <span class="dt">dim=</span><span class="kw">c</span>(n, n))  <span class="co"># p is initially random</span>
edges &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:n^<span class="dv">2</span>, n, <span class="dt">replace =</span> <span class="ot">FALSE</span>)  <span class="co"># select 4 random edges</span>
p1 &lt;-<span class="st"> </span>p; p2 &lt;-<span class="st"> </span>p  <span class="co"># initialize p1 and p2 to the same array</span>

for (edge in edges) {
  p1[edge] &lt;-<span class="st"> </span>.<span class="dv">25</span>
  p2[edge] &lt;-<span class="st"> </span>.<span class="dv">75</span>
}

p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(n, n, <span class="dv">2</span>))
p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2

<span class="co"># visualize the two probability matrices</span>
plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
sg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(n, n))
sg[edges] &lt;-<span class="st"> </span><span class="dv">1</span>
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(sg, <span class="dt">title=</span><span class="st">&quot;Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>As we can see, it is quite immediately clear which edges are part of the subgraph, so our classifier should have no issues. We generate 10 simulated examples per class, and examine the results of of our estimators:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ns =<span class="st"> </span><span class="dv">100</span>

samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(n, n, ns*<span class="dv">2</span>))
samp[,,<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>ns)
samp[,,(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>ns)

Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(ns*<span class="dv">2</span>))
Y[<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="dv">0</span>
Y[(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="dv">1</span>

<span class="co"># approximate estimators and contingency table</span>
train &lt;-<span class="st"> </span><span class="kw">sg.bern.subgraph_train</span>(samp, Y, <span class="dv">4</span>, <span class="dt">coherent=</span><span class="ot">FALSE</span>, <span class="dt">tstat =</span> <span class="st">&quot;fisher&quot;</span>)

<span class="co"># visualize the two probability matrices</span>
plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
estsg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(n, n))
estsg[train$edges] &lt;-<span class="st"> </span><span class="dv">1</span>
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(estsg, <span class="dt">title=</span><span class="st">&quot;Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(n, n, ns*<span class="dv">2</span>))
test[,,<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>ns)
test[,,(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>ns)
test_y &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(<span class="dv">2</span>*ns))
test_y[(ns<span class="dv">+1</span>):<span class="dv">2</span>*ns] &lt;-<span class="st"> </span><span class="dv">1</span>

classifier_res &lt;-<span class="st"> </span><span class="kw">sg.bern.subgraph_classifier</span>(test, train$edges, train$p, train$pi, train$classes)</code></pre></div>
<p>Given 100 examples per class, we can see that our estimated Ps are very close to our true Ps (we investigate this more thoroughly in the vignette <code>bern_graph_estimator</code>), and our subgraph matches the truth perfectly.</p>
</div>
<div id="harder-simulation" class="section level2">
<h2>Harder Simulation</h2>
<p>In this simulation, we will structure our trials very similarly to the previous, however our predictions will not be quite as simple this time. Our true P between class 1 and class 2 will no longer be identical for non-signal edges, as we will add gaussian noise with a cutoff at 0 and 1 (since probabilities cannot exceed 1 nor be lower than 0). We will report cross-validated error and misclassification rate as a function of the number of training examples used, and will also investigate the impact of having an estimate of 2, 4, and 8 signal edges.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ns &lt;-<span class="st"> </span><span class="kw">lseq</span>(<span class="dv">10</span>, <span class="dv">300</span>, <span class="dv">8</span>)
nes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>)

dim &lt;-<span class="st"> </span><span class="dv">4</span>

p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(dim^<span class="dv">2</span>), <span class="dt">dim=</span><span class="kw">c</span>(dim, dim))  <span class="co"># p is initially random</span>
edges &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:dim^<span class="dv">2</span>, <span class="dv">6</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)  <span class="co"># select 6 random edges</span>
p1 &lt;-<span class="st"> </span>p; p2 &lt;-<span class="st"> </span>p <span class="co"># initialize p1 and p2 to the same array with some noise</span>

for (edge in edges) {
  p1[edge] &lt;-<span class="st"> </span>.<span class="dv">3</span>
  p2[edge] &lt;-<span class="st"> </span>.<span class="dv">7</span>
}

p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">rnorm</span>(dim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">1</span>); p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">rnorm</span>(dim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">1</span>)

p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>

p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(dim, dim, <span class="dv">2</span>))
p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2

<span class="co"># visualize the two probability matrices</span>
plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
sg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(dim, dim))
sg[edges] &lt;-<span class="st"> </span><span class="dv">1</span>
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(sg, <span class="dt">title=</span><span class="st">&quot;Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Again, our task appears to be fairly simple, but it should prove far more difficult than our previous task due to the fact that there now exists a class-conditional difference in the non-signal edges as well, although slight.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">results &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">n=</span><span class="kw">c</span>(), <span class="dt">nedges=</span><span class="kw">c</span>(), <span class="dt">error=</span><span class="kw">c</span>(), <span class="dt">miss_edge=</span><span class="kw">c</span>())
for (sim in <span class="dv">1</span>:<span class="dv">10</span>) {
  
  p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(dim^<span class="dv">2</span>), <span class="dt">dim=</span><span class="kw">c</span>(dim, dim))  <span class="co"># p is initially random</span>
  edges &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:dim^<span class="dv">2</span>, <span class="dv">6</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)  <span class="co"># select 6 random edges</span>
  p1 &lt;-<span class="st"> </span>p; p2 &lt;-<span class="st"> </span>p <span class="co"># initialize p1 and p2 to the same array with some noise</span>
  
  for (edge in edges) {
    p1[edge] &lt;-<span class="st"> </span>.<span class="dv">3</span>
    p2[edge] &lt;-<span class="st"> </span>.<span class="dv">7</span>
  }
  p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">rnorm</span>(dim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">1</span>); p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">rnorm</span>(dim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">1</span>)
  
  p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
  
  p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(dim, dim, <span class="dv">2</span>))
  p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
  p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2
  for (n in ns) {
    samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(dim, dim, n*<span class="dv">2</span>))
    samp[,,<span class="dv">1</span>:n] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>n)
    samp[,,(n<span class="dv">+1</span>):(<span class="dv">2</span>*n)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>n)
    
    Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(n*<span class="dv">2</span>))
    Y[<span class="dv">1</span>:n] &lt;-<span class="st"> </span><span class="dv">0</span>
    Y[(n<span class="dv">+1</span>):(<span class="dv">2</span>*n)] &lt;-<span class="st"> </span><span class="dv">1</span>
    for (ne in nes) {
      class_res &lt;-<span class="st"> </span><span class="kw">sg.bern.xval_classifier</span>(<span class="dt">samp=</span>samp, <span class="dt">Y=</span>Y, <span class="dt">nedge=</span>ne, <span class="dt">tstat=</span><span class="st">&quot;fisher&quot;</span>, <span class="dt">coherent =</span> <span class="ot">FALSE</span>, <span class="dt">xval=</span><span class="st">&quot;loo&quot;</span>)
      miss_edge &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span><span class="dv">1</span>/<span class="kw">length</span>(edges)*<span class="kw">sum</span>(edges %in%<span class="st"> </span>class_res$edges)
      results &lt;-<span class="st"> </span><span class="kw">rbind</span>(results, <span class="kw">data.frame</span>(<span class="dt">n=</span>n, <span class="dt">nedges=</span>ne, <span class="dt">error=</span>class_res$error, <span class="dt">miss_edge=</span>miss_edge))    
    }
  }
}</code></pre></div>
<p>and we plot the missed edge rate and the leave-one-out cross validated error:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">results$nedges &lt;-<span class="st"> </span><span class="kw">factor</span>(results$nedges)
me_plot &lt;-<span class="st"> </span><span class="kw">ggplot</span>(results, <span class="kw">aes</span>(<span class="dt">x=</span>n, <span class="dt">y=</span>miss_edge, <span class="dt">color=</span>nedges, <span class="dt">group=</span>nedges)) +
<span class="st">  </span><span class="kw">geom_point</span>() +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.y =</span> mean, <span class="dt">geom =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.data =</span> mean_se, <span class="dt">geom =</span> <span class="st">&quot;errorbar&quot;</span>) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Proportion of Subgraph Edges Missed by Subgraph Estimator&quot;</span>) +
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Number of Training Examples per Class&quot;</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Missed-Edge Rate&quot;</span>)

xv_plot &lt;-<span class="st"> </span><span class="kw">ggplot</span>(results, <span class="kw">aes</span>(<span class="dt">x=</span>n, <span class="dt">y=</span>error, <span class="dt">color=</span>nedges, <span class="dt">group=</span>nedges)) +
<span class="st">  </span><span class="kw">geom_point</span>() +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.y =</span> mean, <span class="dt">geom =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.data =</span> mean_se, <span class="dt">geom =</span> <span class="st">&quot;errorbar&quot;</span>) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Error of Model Estimated with Leave-One-Out Cross Validation&quot;</span>) +
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Number of Training Examples per Class&quot;</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Cross-Validated Error&quot;</span>)

<span class="kw">multiplot</span>(me_plot, xv_plot, <span class="dt">cols=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Intuitively, we can see that more training examples asymptotically decreases our missed0-edge rate and cross-validated error, and choosing more subgraph edges gives us better ability to capture the variation that may be in the data due to signal or consistent class-to-class noise (due to us adding the normally distributed 0-mean gaussian noise to our probability matrices). We see that using 3 edges versus 6 edges gives us a significant difference in our performance metrics, which makes sense as with 4 edges we are not capturing all of our signal edges completely. When we jump from 6 edges to 9 edges in our subgraph, we see only modest improvements, which makes sense as our entire subgraph is only 6 edges total, but 9 edges can still capture some of the class-conditional noise that is also present in our probability matrices.</p>
</div>
<div id="negative-example" class="section level2">
<h2>Negative Example</h2>
<p>In this example, we will explore a situation that an incoherent subgraph classifier will not be able to appropriately handle. Consider the case where we have a far more subtle class-conditional variation, and the bulk of the class-conditional variation captured by only the edges incident a smaller number of our vertices known as the signal vertices. This situation, known as a coherent subgraph, allows us to focus on the vertices that matter most, and consider from this subset the edges that matter most (see the vignette for <code>bern_coherent_subgraph_estimation</code> for more details). Due to the fact that the incoherent estimator will consider all edges, our signal edges may potentially be due to noise. In this example, we will consider 9 vertex graphs, with 10 signal edges distributed about the possible edges incident only vertices 1 and 3. For each class, the probability matrix has 0-mean gaussian noise to add a small amount underlying variation between the two classes. Additionally, with probability <span class="math inline">\(p=.25\)</span> we will rewire (that is, change the connection from connected to unconnected, or vice versa) each edge for each graph. This means that there will be other edges at random that also may look like signal vertices, but these edges (since they are rewired at random) will be purely noise and should not improve our predictive power on successive examples. We would thus expect that our missed-edge rate and leave-one-out cross-validated error will be artificially inflated unless we can account for the fact that most of our signal edges are incident only to one vertex.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xdim &lt;-<span class="st"> </span><span class="dv">9</span>
ydim &lt;-<span class="st"> </span><span class="dv">9</span>
c &lt;-<span class="st"> </span><span class="dv">2</span>  <span class="co"># number of classes</span>
p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, c))

signal_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">23</span>, <span class="dv">26</span>, <span class="dv">21</span>)
p1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(xdim*ydim), <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim))
p1[<span class="kw">upper.tri</span>(p1, <span class="dt">diag=</span><span class="ot">FALSE</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>

p2 &lt;-<span class="st"> </span>p1
for (e in <span class="kw">c</span>(signal_edges)) {
  p1[e] &lt;-<span class="st"> </span>.<span class="dv">3</span>
  p2[e] &lt;-<span class="st"> </span>.<span class="dv">7</span>
}

p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">t</span>(p1) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p1)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">t</span>(p2) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p2)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2

ns =<span class="st"> </span><span class="dv">100</span>

samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim, ns*<span class="dv">2</span>))
samp[,,<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>ns, <span class="dt">rewire=</span>.<span class="dv">25</span>)
samp[,,(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>ns, <span class="dt">rewire=</span>.<span class="dv">25</span>)

Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(ns*<span class="dv">2</span>))
Y[<span class="dv">1</span>:ns] &lt;-<span class="st"> </span><span class="dv">0</span>
Y[(ns<span class="dv">+1</span>):(<span class="dv">2</span>*ns)] &lt;-<span class="st"> </span><span class="dv">1</span>


plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;True P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
sg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim))
sg[signal_edges] &lt;-<span class="st"> </span><span class="dv">1</span>
sg &lt;-<span class="st"> </span>sg +<span class="st"> </span><span class="kw">t</span>(sg) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(sg))
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(sg, <span class="dt">title=</span><span class="st">&quot;True Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>As we can see from the plot of edges in our theoretically optimal subgraph, the signal vertices are vertices 1 and 2. As we show below, however, using an incoherent estimator does not necessarily return such a favorable output.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># approximate estimators and contingency table</span>
train &lt;-<span class="st"> </span><span class="kw">sg.bern.subgraph_train</span>(samp, Y, <span class="dv">12</span>, <span class="dt">coherent=</span><span class="ot">FALSE</span>, <span class="dt">tstat =</span> <span class="st">&quot;fisher&quot;</span>)

<span class="co"># visualize the two probability matrices</span>
plot_p1 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">1</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 1&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
plot_p2 &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(train$p[,,<span class="dv">2</span>], <span class="dt">title=</span><span class="st">&quot;Est P, class 2&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;p&quot;</span>)
estsg &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, xdim))
estsg[train$edges] &lt;-<span class="st"> </span><span class="dv">1</span>
plot_sg &lt;-<span class="st"> </span><span class="kw">fmriu.plot.plot_square</span>(estsg, <span class="dt">title=</span><span class="st">&quot;Estimated Subgraph&quot;</span>, <span class="dt">xlabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">ylabel=</span><span class="st">&quot;vertex&quot;</span>, <span class="dt">legend=</span><span class="st">&quot;edge&quot;</span>)
<span class="kw">multiplot</span>(plot_p1, plot_p2, plot_sg, <span class="dt">cols =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>As we can see, we get some of the edges right, but make many errors, and have not really captured the idea that the signal edges are entirely present in the first and third vertices. Let’s take a look at how our performance is in a full-simulation setting:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ns &lt;-<span class="st"> </span><span class="kw">lseq</span>(<span class="dv">10</span>, <span class="dv">300</span>, <span class="dv">8</span>)
nes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">6</span>, <span class="dv">12</span>, <span class="dv">18</span>)
results &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">n=</span><span class="kw">c</span>(), <span class="dt">nedges=</span><span class="kw">c</span>(), <span class="dt">error=</span><span class="kw">c</span>(), <span class="dt">miss_edge=</span><span class="kw">c</span>())
for (sim in <span class="dv">1</span>:<span class="dv">10</span>) {
  <span class="kw">print</span>(sim)
  xdim &lt;-<span class="st"> </span><span class="dv">9</span>
  ydim &lt;-<span class="st"> </span><span class="dv">9</span>
  c &lt;-<span class="st"> </span><span class="dv">2</span>  <span class="co"># number of classes</span>
  p &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, c))
  
  signal_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">23</span>, <span class="dv">26</span>, <span class="dv">21</span>)
  p1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(xdim*ydim), <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim))
  p1[<span class="kw">upper.tri</span>(p1, <span class="dt">diag=</span><span class="ot">FALSE</span>)] &lt;-<span class="st"> </span><span class="dv">0</span>
  
  p2 &lt;-<span class="st"> </span>p1
  for (e in <span class="kw">c</span>(signal_edges)) {
    p1[e] &lt;-<span class="st"> </span>.<span class="dv">3</span>
    p2[e] &lt;-<span class="st"> </span>.<span class="dv">7</span>
  }
  
  p1 &lt;-<span class="st"> </span>p1 +<span class="st"> </span><span class="kw">t</span>(p1) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p1)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
  p2 &lt;-<span class="st"> </span>p2 +<span class="st"> </span><span class="kw">t</span>(p2) -<span class="st"> </span><span class="kw">diag</span>(<span class="kw">diag</span>(p2)) +<span class="st"> </span><span class="kw">rnorm</span>(xdim^<span class="dv">2</span>, <span class="dt">mean=</span><span class="dv">0</span>, <span class="dt">sd=</span>.<span class="dv">05</span>)
  p1[p1 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p1[p1 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>; p2[p2 &gt;<span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; p2[p2 &lt;<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
  p[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>p1
  p[,,<span class="dv">2</span>] &lt;-<span class="st"> </span>p2

  for (n in ns) {
    samp &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(xdim, ydim, n*<span class="dv">2</span>))
    samp[,,<span class="dv">1</span>:n] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">1</span>], <span class="dt">s=</span>n, <span class="dt">rewire=</span>.<span class="dv">25</span>)
    samp[,,(n<span class="dv">+1</span>):(<span class="dv">2</span>*n)] &lt;-<span class="st"> </span><span class="kw">sg.bern.sample_graph</span>(p[,,<span class="dv">2</span>], <span class="dt">s=</span>n, <span class="dt">rewire=</span>.<span class="dv">25</span>)
    
    Y &lt;-<span class="kw">array</span>(<span class="ot">NaN</span>, <span class="dt">dim=</span><span class="kw">c</span>(n*<span class="dv">2</span>))
    Y[<span class="dv">1</span>:n] &lt;-<span class="st"> </span><span class="dv">0</span>
    Y[(n<span class="dv">+1</span>):(<span class="dv">2</span>*n)] &lt;-<span class="st"> </span><span class="dv">1</span>
    for (ne in nes) {
      class_res &lt;-<span class="st"> </span><span class="kw">sg.bern.xval_classifier</span>(<span class="dt">samp=</span>samp, <span class="dt">Y=</span>Y, <span class="dt">nedge=</span>ne, <span class="dt">tstat=</span><span class="st">&quot;fisher&quot;</span>, <span class="dt">coherent =</span> <span class="ot">FALSE</span>, <span class="dt">xval=</span><span class="st">&quot;loo&quot;</span>)
      true_edges &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">28</span>, <span class="dv">55</span>, <span class="dv">73</span>, <span class="dv">19</span>, <span class="dv">37</span>, <span class="dv">64</span>)
      miss_edge &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span><span class="dv">1</span>/<span class="kw">length</span>(true_edges)*<span class="kw">sum</span>(true_edges %in%<span class="st"> </span>class_res$edges)
      results &lt;-<span class="st"> </span><span class="kw">rbind</span>(results, <span class="kw">data.frame</span>(<span class="dt">n=</span>n, <span class="dt">nedges=</span>ne, <span class="dt">error=</span>class_res$error, <span class="dt">miss_edge=</span>miss_edge))    
    }
  }
}</code></pre></div>
<pre><code>## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">results$nedges &lt;-<span class="st"> </span><span class="kw">factor</span>(results$nedges)
me_plot &lt;-<span class="st"> </span><span class="kw">ggplot</span>(results, <span class="kw">aes</span>(<span class="dt">x=</span>n, <span class="dt">y=</span>miss_edge, <span class="dt">color=</span>nedges, <span class="dt">group=</span>nedges)) +
<span class="st">  </span><span class="kw">geom_point</span>() +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.y =</span> mean, <span class="dt">geom =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.data =</span> mean_se, <span class="dt">geom =</span> <span class="st">&quot;errorbar&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Proportion of Edges Missed by Incoherent Subgraph Estimator&quot;</span>) +
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Number of Training Examples per Class&quot;</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Missed-Edge Rate&quot;</span>)

xv_plot &lt;-<span class="st"> </span><span class="kw">ggplot</span>(results, <span class="kw">aes</span>(<span class="dt">x=</span>n, <span class="dt">y=</span>error, <span class="dt">color=</span>nedges, <span class="dt">group=</span>nedges)) +
<span class="st">  </span><span class="kw">geom_point</span>() +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.y =</span> mean, <span class="dt">geom =</span> <span class="st">&quot;line&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">stat_summary</span>(<span class="dt">fun.data =</span> mean_se, <span class="dt">geom =</span> <span class="st">&quot;errorbar&quot;</span>, <span class="dt">size=</span><span class="dv">2</span>) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Error of Model Estimated with Leave-One-Out Cross Validation&quot;</span>) +
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Number of Training Examples per Class&quot;</span>) +
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Cross-Validated Error&quot;</span>)

<span class="kw">multiplot</span>(me_plot, xv_plot, <span class="dt">cols=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Our cross-validated error is not bad, however, our missed-edge rate is quite poor.</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
